/*
 * Copyright (c) 2018-2020 Damien Ciabrini
 * This file is part of ngdevkit
 *
 * ngdevkit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ngdevkit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ngdevkit.  If not, see <http://www.gnu.org/licenses/>.
 */

// Additional resources for sprites
// https://wiki.neogeodev.org/index.php?title=Sprites

#include <ngdevkit/neogeo.h>
#include <ngdevkit/ng-fix.h>
#include <stdio.h>

// Current state of player 1's controller
extern u8 bios_p1current;

// Address of Sprite Control Block in VRAM
#define ADDR_SCB1      0
#define ADDR_SCB2 0x8000
#define ADDR_SCB3 0x8200

/// The Neo Geo BIOS uses the first tiles in the C-ROM
/// up to tile 255. So use the first available one
#define START_TILE 256


void init_palette() {
    /// first 16 colors palette for the fix tiles
    /// second 16 colors palette for the sprite
    const u16 clut[]= { 0x8000, 0x0fa0, 0x0533, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
                        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
                        0x0000, 0x0fff, 0x0ddd, 0x0aaa, 0x7555, 0x306E, 0x0000, 0x0000,
                        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 };

    /// Initialize the two palettes in the first palette bank
    for (u16 i=0;i<32; i++) {
        MMAP_PALBANK1[i]=clut[i];
    }
}


s16 x=40;
s16 y=-80;

// Sprite setup.
//
// The sprite is 15 tiles long x 4 tiles tall
// For the Neo Geo hardware, it's a series of
// 15 concatenated vertical sprites of 4 tiles
void init_sprite() {
    // Every write to the VRAM will increment the
    // VRAM address pointer by 1 byte.
    *REG_VRAMMOD=1;

    // Set the tile information (tile number, color, mirror)
    // in the Sprite Control Block 1 (SCB1)
    for (u8 i=0; i<15; i++) {
         // address of the i-th sprite in SCB1
        *REG_VRAMADDR=ADDR_SCB1+(i*64); // i-th sprite in SCB1

        u16 tile = START_TILE + i;      // i-th tile in c-ROM
        u16 attr = 1<<8;                // palette 1, no mirrorring
        *REG_VRAMRW=tile;
        *REG_VRAMRW=attr;

        // the next write in VRAM targets the subsequent vertical
        // tiles for this i-th sprite.
        *REG_VRAMRW=tile+15;            // next vertical tile
        *REG_VRAMRW=attr;               // palette 1, no mirroring
        *REG_VRAMRW=tile+30;            // ...
        *REG_VRAMRW=attr;
        *REG_VRAMRW=tile+45;
        *REG_VRAMRW=attr;
    }

    // Sprite zoom, size and position are specified in Sprite Control
    // Block 2, 3 and 4.
    // The first vertical sprite controls the overall location and zoom,
    // the other 15 vertical sprites are just defined as 'sticky', i.e.
    // they follow the location of their previous sibling.

    // SCB2, SCB3 and SCB4 are 0x200 bytes away from each other
    *REG_VRAMMOD=0x200;

    // Vertical sprite 0
    *REG_VRAMADDR=ADDR_SCB2;
    // SCB2: max zoom
    *REG_VRAMRW=0xFFF;
    // SCB3: y position, not sticky, 4 tiles tall
    *REG_VRAMRW=(y<<7)+4;
    // SCB4: x position
    *REG_VRAMRW=(x<<7);

    // the remaining 14 vertical sprites are sticky
    for (u16 i=1; i<15; i++) {
        *REG_VRAMADDR=ADDR_SCB2+i;      // i-th sprite
        *REG_VRAMRW=0xFFF;              // max zoom
        *REG_VRAMRW=1<<6;;              // sticky
    }
}


char joystate[5]={'0','0','0','0',0};

// Get joystick status and move sprite position
void check_move_sprite()
{
    u8 u=(bios_p1current & CNT_UP);
    u8 d=(bios_p1current & CNT_DOWN);
    u8 l=(bios_p1current & CNT_LEFT);
    u8 r=(bios_p1current & CNT_RIGHT);

    joystate[0]=u?'1':'0';
    joystate[1]=d?'1':'0';
    joystate[2]=l?'1':'0';
    joystate[3]=r?'1':'0';

    if (u) {y+=1;}
    if (d) {y-=1;}
    if (l) {x-=1;}
    if (r) {x+=1;}

    // Update sprite position
    *REG_VRAMMOD=0x200;
    *REG_VRAMADDR=ADDR_SCB3;
    *REG_VRAMRW=(y<<7)+4;
    *REG_VRAMRW=(x<<7);
}


// Vertical blanking.
volatile u8 vblank=0;

// At each screen refresh (1/60s in NTSC), a Vertical Blank
// Interrupt is generated by the Neo Geo, and the C runtime
// automatically calls back this function below.
void rom_callback_VBlank() {
    vblank=1;
}

// Active wait until we see a screen refresh
void ng_wait_vblank() {
    while (!vblank);
    vblank=0;
}


int main(void) {
    ng_cls();
    init_palette();
    init_sprite();

    ng_text_tall(27, 26, 0, "SPRITE TEST");
    ng_text(3, 18, 0, "Move the sprite with the joystick!");

    char str[10];
    u8 x = 0;

    for(;;) {
        snprintf(str, 10, "frame %2d", x);
        ng_text(2, 26, 0, str);
        x=(x+1)%60;

        check_move_sprite();
        snprintf(str, 15, "JS1 %s", joystate);
        ng_text(2, 27, 0, str);

        ng_wait_vblank();
    }
    return 0;
}
